#○ TCP
    네트워크 통신에서 신뢰적인 연결방식
    비신뢰적 네트워크에서 신뢰적 네트워크를 보장할 수 있도록 하는 프로토콜

#### 신뢰적인 네트워크를 보장하기 위해 해결해야 할 4가지 문제
    ○ 손실: 패킷이 손실될 수 있는 문제
    ○ 순서 바뀜: 패킷의 순서가 바뀔 수 있는 문제
    ○ 혼잡 : 네트워크가 혼잡한 문제
    ○ 과부하(overload): 수신자가 과부하 되는 상태

# ○ 흐름제어와 혼잡제어

## 흐름제어
    수신측이 송신측 보다 데이터 처리속도가 빠르면 문제가 없으나 송신측 속도가 빠를 경우 흐름제어

    수신측에서 제한한 용량을 초과시 데이터가 손실될 수 있고 손실 시 불필요한 응답과 불필요한 데이터 전송이 빈번하게 발생

#### 해결방법
    - Stop and wait: 매번 전송한 패킷에 대해 확인 응답을 받아야만 송신측에서 이후 패킷을 전송하는 방법

    - sliding Window: 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게되어 데이터 흐름을 동적으로 조절하는 기법

## 혼잡제어
    송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달되는데 만약 한 라우터에 요청이 몰리게 되면 데이터를 모두 처리 할 수 없게 된다.
    이런경우 호스트는 재전송을 하게 되고 혼잡을 가중시켜 오버플로우나 데이터 손실을 유발한다.
    
    이러한 상황을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데 이러한 작업을 혼잡제어라고 한다.
    흐름제어가 송,수신측 사이의 전송속도를 다루는데 반해 혼잡제어는 호스트와 라우터를 포함한 더 넓은 관점에서 전송문제를 다룸

#### 해결방법
    ○ AIMD(Additive Increase / Multiplicative Decrease) 
        - 처음에 패킷을 하나씩 보내어 문제없이 도착하면 단위시간 내 보내는 패킷의 수를 1 늘려가며 전송하는 방식
        
        - 패킷전송에 실패하거나 일정 시간을 넘으면 패킷을 보내는 속도를 절반으로 줄임

        - 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고 네트워크의 혼잡을 미리 감지하지 못하는 단점

    ○ Slow Start
        - 송신 측이 1부터 패킷 손실이 일어날 때 까지 지수승으로 증가시키는 방법

        - 패킷 손실을 감지하면 사이즈는 1로 떨어트림 

        - 처음에는 네트워크 수용량을 예측하기 힘들지만 한번 혼잡현상이 발생하면 네트워크의 수용량을 어느정도 예측 가능

        - 따라서 혼잡 현상이 발생한 사이즈의 절반까지는 이전까지 지수승으로 증가시키다 그 이후부터는 완만하게 +1씩 증가시킴

    ○ Fast Retransmit(빠른 재전송)   
        - 패킷을 받는쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK를 보낸다.
    
        - 순서대로 도착한 마지막 패킷의 다음 패킷 순번을 ACK에 실어 보내는데 이 과정에서 중간 패킷이 손실나면 보내는 측에서 순번이 중복된 ACK를 받게되고 문제를 감지하는 순간 재전송 해 줌
    
        - 빠른 재전송은 중복 패킷을 3개 받으면 재전송 하며 이러한 상황은 혼잡을 의미하므로 사이즈를 줄이게 된다.

    ○ Fast Recovery(빠른 회복)
        - 혼잡 상태가 되면 사이즈를 1로 줄이지 않고 절반으로 줄인뒤 선형증가 시키는 방법

        - 혼잡 상황을 한번 겪고 나서는 순수 AIMD 방식으로 작동

# ○ UDP
    - User Datagram Protocol의 약자로 데이터를 데이터그램 단위로 처리하는 프로토콜
    
    - 비연결형, 신뢰성 없는 전송 프로토콜

    - 데이터그램 단위로 쪼개가며 전송을 하므로 전송계층
        

## TCP와 UDP의 등장 배경

    Ip의 역할은 host to host만을 지원하는데 장치에서 장치로 이동은 IP로 해결되나 하나의 장비안에서 수 많은 프로그램의 통신이 이뤄질 경우 IP로는 한계가 있다.

    또한 IP에서 오류가 발생하면 ICMP에서 알려 주지만 알려주기만 할 뿐 대처를 하지못하기 때문에 더 위 계층에서 이를 처리해줘야 한다. 

    - 1번을 해결하기 위해 포트번호가 나오게 되었고 2번을 해결하기 위해 상위 프로토콜인 TCP UDP가 등장하게 되었다.


#### TCP, UDP는 어떻게 오류를 해결?
    TCP는 데이터의 분실, 중복, 순서가 뒤바뀜을 자동으로 보정해줘 송수신 데이터의 정확한 전달을 할 수 있게 해준다.
    
    UDP는 IP가 제공하는 수준을 전달하는 IP 상위 계층의 프로토콜인데 TCP와 다르게 에러가 있을 수 있고 재전송이나 순서가 바뀔 수 있어 이경우 어플리케이션에서 처리하는 번거로움이 존재한다.

#### UDP의 사용 이유

    데이터 처리가 TCP보다 빠르다는 장점이 있다.
    
    주로 스트리밍 서비스나 온라인 게임에서 사용된다.

#### DNS에서 UDP를 사용하는 이유

    - request의 양이 적다 => UDP request에 담길 수 있음
    - 3-way handshaking으로 연결을 유지 할 필요가 없다.
    - resquest에 대한 손실은 응용계층에서 제어가 가능하다
    - port 53번
 
    @예외: 크기가 512가 넘을 때 TCP를 사용 (UDP 는 512 가 제한)
